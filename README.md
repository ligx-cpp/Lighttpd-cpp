# Lighttpd-cpp


        感谢CSDN上的一位博主：jiange_zh 他的博客给了我很多启发.写在前面 非常感谢！
        
        
2019-09-06更新：解决了一个线程只能运行连接一个客户端的问题;这个问题也反映了我很愚蠢;既然我用的是
libevent库;libevent底层封装的都是多路I/O函数,例如select,epool这样的函数;这些都是能同时响应多个连
接的函数;怎么会只能连接一个客户端呢？所以这确实是我的代码逻辑有问题;很快我发现了问题是我的线程池
模型和libevent库不太兼容，我的线程池的消息传递方式是通过设置条件变量的方式;我原先的想法是每当我
的主线程监听到来自客户端的连接之后返回一个套接字;之后这个套接字就会被存放在一个消息队列里面当我
主动随机唤醒一个线程(为什么是随即的?因为条件变量的机制就是随机唤醒一个线程)后这个线程就会从阻塞
中退出然后将消息从消息队列中取出;进入base循环执行读写功能;事实上这确实是我有点想当然；而且随机唤
醒一个线程这种机制对于高并发连接时有可能会导致某一个连接的连接数很多;而其他线程的连接数较少,从而
导致负载不均衡问题;然后是上一次更新曾经出现的问题当某一客户端异常关闭时会导致服务器端异常关闭;
而且在已经关闭掉的客户端之后新连接的客户端无法与服务器进行正常读写(连接是正常连接的);我在综合考
量了这些问题之后我把这些问题定位在两个点上;一:条件变量机制问题很大,不可用.二:读写机制有问题,手
动写的读写(read和write)回调函数可能在异常处理方面考虑的不是那么全面从而导致了一系列问题。然后在
网上搜索有关的解决方案;我竟然找到了和我有同样想法的博客。。。我运行了他的程序，他解决了我上面说
的一部分问题；但是没有解决客户端异常关闭后;后面继续连接上来的客户端读写异常问题;然后借鉴了他的做
法;将条件变量机制改为用管道在线程间通信并且用专门的一个(event)事件去监听管道读端,一旦有消息就调用
读写函数;完美的和libevent模型相契合;这里给大佬点个赞！.还有一个问题没解决“读写问题”因为刚开始看的
启蒙博客是jiange_zh博主只是用了一下没有缓冲区的,在我走投无路的抱着试试看的想法我学习了一下带缓冲
区的event事实上常用的网络编程都是用的bufferevent;为什么我会去尝试bufferevent呢?因为我发现bufferevent
中的读写函数是被封装的既然是别人封装好的;我觉得他的异常读取机制肯定比我这个菜鸟做的更好,考虑的更
多;事实上确实如此;bufferevent确实完美的解决了这个问题完成了我的这个项目的前一些部分;回显部分;后续待更新。。。


2019-09-02更新：本程序遇到的一些问题：首先是在我开启多个客户端连接时如果其中一个客户端强制关闭后;相应的服务器
端也会直接退出这个问题 解释如下：当强行关闭客户终端后，client进程交付给初始进程。等初始进程查询
到client后将它杀掉。但是在杀掉之前，由于关掉了终端（主要是关掉了输入缓冲区），导致本来阻塞中的
cin或scanf返回EOF，程序得以继续执行send和recv操作。服务器发现client有消息传入，但是在尝试回应
client的时候client被初始进程杀掉。然后就变成了给已经关闭的socket发送数据。当服务器监听并接受一
个客户端链接的时候, 可以不断向客户端发送数据, 这时如果客户端断开socket链接, 服务器继续向一个关
闭的socket 发送数据(send, write)的时候, 系统会默认对服务器进程发送一个SIGPIPE信号, 这个信号的
默认动作就是终止当前服务器进程。  解决方案:我利用read函数的读取错误返回来的信息,一旦返回的是错
误信息，我就让rwhand对象中的“监听事件循环”退出并且析构掉rwhand对象这样程序就不会出现异常退出问题

 另一个大问题是如何让我的一个线程同时处理多个连接;现在的情况是我一个线程只能处理一个连接如果当
前连接不放开的话就无法收到另一个新套接字的读写消息;其他问题遇到了再补充。。。


   2019-08更新：做这个项目的初衷(姑且称它为项目)：在做这个小项目之前我也是看了不少书，比如:UNIX环境高级编程 
,linux高性能服务器编程，C++primer 曾经也读过经典的C++live555源码 lighttpd源码 linux操作系统的
简单使用等等还有就不一一列举，我一直秉承着用什么学什么的原则去学习,我知道如果只是去读这些工具
书但不去实践的话，就会很快忘记曾经读过的内容，所以一直就有个想法去做一个“像样”的项目，一方面这
样做会让自己很有成就感，其次是可以巩固所学，所以就在网上找一些别人推荐的项目来做一做，很快就确
定了两个目标:webbench和lighttpd这两个；一个是网站压力测试工具,一个是http轻量级服务器,两个都是
C语言写的;所以就萌生了用面向对象的思想去实现同样功能的东西;最先动手做的是webbench，因为它简单;
我是个半路出家的;和科班出身的人比作东西肯定是差了十万八千里;所以就先从简单的做起。废话太多了。。。


    
   项目大体流程：lighttpd源码是用的watch-worker(监视者-工作者模式)是由一个进程去fork多个子进程
的模式,这里我打算用线程池的方式去代替上述模式;优点是可以减少资源开销,提高响应速度；节省了进程多次
创建和销毁的时间;因为线程池会提前创建线程等待事件的到来。线程池也是从别处学习得来,用到了我的项目当
中,然后我采用的是libevent来实现我的代码(linux高性能服务器编程中有介绍,源码只是大致的浏览过)项目首
先通过在主线程监听客户端的连接然后将连接的套接字传到已经阻塞等待的子线程中进行相应的处理。lighttpd
的核心处理消息机制(状态机)也运用到我的项目当中来:暂时就想到了这么多(后面等项目完成后再补充。。待续)
