# Lighttpd-cpp


        感谢CSDN上的一位博主：jiange_zh 他的博客给了我很多启发.写在前面 非常感谢！
2019-09-17更新：这次更新完成了整个项目的基本功能.即完成了从浏览器的搜索窗输入192.168.56.101:4000/html/index.html
然后从浏览器中显示index.html中的内容.这次更新基本上是接近了项目的尾声,按照我的想法接下来要做的是
对这个项目增加一些特色功能比如状态机功能;这个暂且放置;先说一下在这期间遇到的一些问题:首先是调用第
三方库解析http请求时始终不成功;我首先是找到了http_parser(第三方库的名字)的github源码地址;并且仔细
阅读了它的使用说明并且我在网上找到了一个使用示例.并且也是照着做的;不过还是有问题它始终显示我解析的
url的前四个字符(因为首先解析的就是url)然后就显示terminate called after throwing an instance of 'std::logic_error' 
what(): basic_string::_S_construct NULL not valid;网上的解析是对空指针进行操作
然后左改右改也没找到问题出在哪里...大概是在那天晚上我被折磨的筋疲力尽的时候我开始静下心来去仔细
分析他的使用说明中的每一个参数的意义的时候我发现了我的错误来源:在http_parser_execute(parser,&settings,buffer,buffer_num)
这一句中,问题就处在最后一个参数上,我初以为最后一个参数像read()函数那样是buffer中的字节大小,然后我的写法是
http_parser_execute(parser,&settings,buffer,sizeof(buffer));但是问题在于我传进来的buffer是一个指针,
sizeof(buffer)此时仅仅表示该指针所占内存的大小,而不是buffer所指向内存的大小,这样继续执行下去就报错了;
改了以后就能正确运行了并显示了.问题最后给出第三方库的github源码地址https://github.com/nodejs/http-parser.git 
在此处附上一份静态库和动态库之间的区别：静态库和动态库的最大区别,(1)静态情况下,把库直接加载到程序中,而
动态库链接的时候,它只是保留接口,将动态库与程序代码独立,这样就可以提高代码的可复用度，和降低程序的耦合
度。(2)静态库在程序编译时会被连接到目标代码中，程序运行时将不再需要该静态库。动态库在程序编译时并不
会被连接到目标代码中，而是在程序运行是才被载入，因此在程序运行时还需要动态库存在
        
2019-09-12更新：这次更新给我的程序在回显的基础上添加了一些功能;只有回显显得整个程序很单调这次更新
我添加了能使我的服务器在浏览器上链接的这项功能其实这个功能;刚开始没有什么想法;故在网上查找了一些
资料;也参考了 jiange_zh 大佬的博客,最终也总结出来了要实现这个功能我需要怎么做...

其实也很简单;我之前也做过简单的服务器只不过是之前输入URL请求都是在命令行;现在我把输入URL的地方放
在了浏览器的搜索框里链接原理还是一样的;同理当我的服务器收到消息以后要返回给客户端;简单情况是我的
客户端也是命令行;命令行收到消息显示在屏幕上;而现在我返回的消息要在浏览器中显示;这在返回的响应体
中需要一些前段代码,在此处不是我们的重点,暂且不论.我们需要关注的是怎么把在命令行输入和响应的消息
转移到浏览器上?我们在此引入了插件系统.正如lighttpd那本书上所说的那样:灵活的插件结构使用户可以轻
易地修改服务器功能而不用改变lighttpd的核心代码.多个插件的同时存在使lighttpd应用程序以一种合理的
方式组织和调用.我想说明的是加载类这个方法是一个难点同时也是我的这个项目的亮点之一.我们知道如果
你想在实现插件时用动态库来实现,如果这个库用C语言来实现那么是很轻松的.用dlopen,dlsym,dlclose,来实
现就可以了,但是如果你想用C++来实现动态的装载一个库的话(由于dlopen这类函数是C语言的函数并没有提供
一个合适的方式来装载类;还有一个原因是C++的name mangling问题)还是非常困难的;解决方案就是使用extern "C"
这可以算是C++的关键字;加载类的时候因为我们无法通过new来创建类的实例,因为类不是在可执行文件中定义的,
是在动态库.so中的;那么如何来解决呢？答案是利用多态性.我们在可执行中文件定义一个带有虚成员函数的接
口基类,而在动态库中定义派生类.接下来是利用设计模式中的工厂方法模式在动态库中定义两个附加的函数一个
用来创建一个类的实例，一个用来delete该类对象;且这两个函数都用extern "C"来修饰.还有就是在使用加载
类时需要注意的点这里我就不一一介绍了有兴趣的话可以去http://blog.chinaunix.net/uid-12072359-id-2960897.html 这里看看,作者讲解的非常详细我也是在这里得到了如何去解决这个问题。

我的解决方案就是来自这里用的是加载类的方法;目前还存在的问题是对配置文件不是很清楚,除此之外我还想
在之后的时间里在里面加入日志系统;目前lighttpd的核心状态机模型还没有加入进去;待续。。。
　　


2019-09-06更新：解决了一个线程只能运行连接一个客户端的问题;这个问题也反映了我很愚蠢;既然我用的是
libevent库;libevent底层封装的都是多路I/O函数,例如select,epool这样的函数;这些都是能同时响应多个连
接的函数;怎么会只能连接一个客户端呢？所以这确实是我的代码逻辑有问题;很快我发现了问题是我的线程池
模型和libevent库不太兼容，我的线程池的消息传递方式是通过设置条件变量的方式;我原先的想法是每当我
的主线程监听到来自客户端的连接之后返回一个套接字;之后这个套接字就会被存放在一个消息队列里面当我
主动随机唤醒一个线程(为什么是随即的?因为条件变量的机制就是随机唤醒一个线程)后这个线程就会从阻塞
中退出然后将消息从消息队列中取出;进入base循环执行读写功能;事实上这确实是我有点想当然；而且随机唤
醒一个线程这种机制对于高并发连接时有可能会导致某一个连接的连接数很多;而其他线程的连接数较少,从而
导致负载不均衡问题;然后是上一次更新曾经出现的问题当某一客户端异常关闭时会导致服务器端异常关闭;
而且在已经关闭掉的客户端之后新连接的客户端无法与服务器进行正常读写(连接是正常连接的);我在综合考
量了这些问题之后我把这些问题定位在两个点上;一:条件变量机制问题很大,不可用.二:读写机制有问题,手
动写的读写(read和write)回调函数可能在异常处理方面考虑的不是那么全面从而导致了一系列问题。然后在
网上搜索有关的解决方案;我竟然找到了和我有同样想法的博客。。。我运行了他的程序，他解决了我上面说
的一部分问题；但是没有解决客户端异常关闭后;后面继续连接上来的客户端读写异常问题;然后借鉴了他的做
法;将条件变量机制改为用管道在线程间通信并且用专门的一个(event)事件去监听管道读端,一旦有消息就调用
读写函数;完美的和libevent模型相契合;这里给大佬点个赞！.还有一个问题没解决“读写问题”因为刚开始看的
启蒙博客是jiange_zh博主只是用了一下没有缓冲区的,在我走投无路的抱着试试看的想法我学习了一下带缓冲
区的event事实上常用的网络编程都是用的bufferevent;为什么我会去尝试bufferevent呢?因为我发现bufferevent
中的读写函数是被封装的既然是别人封装好的;我觉得他的异常读取机制肯定比我这个菜鸟做的更好,考虑的更
多;事实上确实如此;bufferevent确实完美的解决了这个问题完成了我的这个项目的前一些部分;回显部分;后续待更新。。。


2019-09-02更新：本程序遇到的一些问题：首先是在我开启多个客户端连接时如果其中一个客户端强制关闭后;相应的服务器
端也会直接退出这个问题 解释如下：当强行关闭客户终端后，client进程交付给初始进程。等初始进程查询
到client后将它杀掉。但是在杀掉之前，由于关掉了终端（主要是关掉了输入缓冲区），导致本来阻塞中的
cin或scanf返回EOF，程序得以继续执行send和recv操作。服务器发现client有消息传入，但是在尝试回应
client的时候client被初始进程杀掉。然后就变成了给已经关闭的socket发送数据。当服务器监听并接受一
个客户端链接的时候, 可以不断向客户端发送数据, 这时如果客户端断开socket链接, 服务器继续向一个关
闭的socket 发送数据(send, write)的时候, 系统会默认对服务器进程发送一个SIGPIPE信号, 这个信号的
默认动作就是终止当前服务器进程。  解决方案:我利用read函数的读取错误返回来的信息,一旦返回的是错
误信息，我就让rwhand对象中的“监听事件循环”退出并且析构掉rwhand对象这样程序就不会出现异常退出问题

 另一个大问题是如何让我的一个线程同时处理多个连接;现在的情况是我一个线程只能处理一个连接如果当
前连接不放开的话就无法收到另一个新套接字的读写消息;其他问题遇到了再补充。。。


   2019-08更新：做这个项目的初衷(姑且称它为项目)：我一直秉承着用什么学什么的原则去学习,我知道
如果只是去读这些工具书但不去实践的话，就会很快忘记曾经读过的内容，所以一直就有个想法去做一个
“像样”的项目，一方面这样做会让自己很有成就感，其次是可以巩固所学，所以就在网上找一些别人推荐
的项目来做一做，很快就确定了两个目标:webbench和lighttpd这两个；一个是网站压力测试工具,一个是http
轻量级服务器,两个都是C语言写的;所以就萌生了用面向对象的思想去实现同样功能的东西;最先动手做的是
webbench，因为它简单;我是个半路出家的;和科班出身的人比作东西肯定是差了十万八千里;所以就先从简单
的做起。废话太多了。。。


    
   项目大体流程：lighttpd源码是用的watch-worker(监视者-工作者模式)是由一个进程去fork多个子进程
的模式,这里我打算用线程池的方式去代替上述模式;优点是可以减少资源开销,提高响应速度；节省了进程多次
创建和销毁的时间;因为线程池会提前创建线程等待事件的到来。线程池也是从别处学习得来,用到了我的项目当
中,然后我采用的是libevent来实现我的代码(linux高性能服务器编程中有介绍,源码只是大致的浏览过)项目首
先通过在主线程监听客户端的连接然后将连接的套接字传到已经阻塞等待的子线程中进行相应的处理。lighttpd
的核心处理消息机制(状态机)也运用到我的项目当中来:暂时就想到了这么多(后面等项目完成后再补充。。待续)
